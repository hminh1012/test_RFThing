#define BLYNK_TEMPLATE_ID ""
#define BLYNK_TEMPLATE_NAME ""
#define BLYNK_FIRMWARE_VERSION ""

#define BLYNK_PRINT Serial
#define APP_DEBUG

#include <Wire.h>
#include <WiFi.h>
#include <BlynkSimpleEsp32.h>
#include <Kionix_KX023.h>
#include <math.h>

// --------- Blynk / WiFi ----------
char auth[] = "YOUR_BLYNK_AUTH_TOKEN"; 
char ssid[] = "YOUR_WIFI_SSID";
char pass[] = "YOUR_WIFI_PASSWORD";

// --------- Hardware ----------
#define STATUS_LED 4   // led b√°o tr·∫°ng th√°i
KX023 myIMU;
float ax, ay, az;

// --------- Free-fall params (tune n·∫øu c·∫ßn) ----------
const float FREEFALL_THRESHOLD = 0.25;   // mag < 0.25 g coi l√† g·∫ßn free-fall (th·ª≠ nghi·ªám)
const unsigned long HOLD_TIME_MS = 150;  // c·∫ßn gi·ªØ d∆∞·ªõi threshold trong 150 ms li√™n t·ª•c
const unsigned long SAMPLE_INTERVAL_MS = 50; // ƒë·ªçc m·ªói 50 ms

// tr·∫°ng th√°i
bool sensorInitialized = false;
bool sensorActive = true;   // n·∫øu mu·ªën, c√≥ th·ªÉ l√†m ƒë·ªÉ b·∫≠t/t·∫Øt b·∫±ng app
bool freefallTriggered = false;

// b·ªô ƒë·∫øm th·ªùi gian
unsigned long freefallStart = 0;
unsigned long lastSample = 0;

// ---------- Safe I2C read helper ----------
bool safeReadAccel(float *x, float *y, float *z) {
  // th·ª≠ v√†i l·∫ßn tr∆∞·ªõc khi reset bus
  for (int i=0; i<3; i++) {
    if (myIMU.readAsynchronousReadBackAccelerationData(x, y, z) == KX023_STATUS_OK) {
      return true;
    }
    delay(5);
  }
  // N·∫øu fail 3 l·∫ßn, reset bus nh·∫π
  Serial.println("‚ö†Ô∏è I2C read failed 3x -> reset Wire bus");
  Wire.end();
  delay(20);
  Wire.begin(5, 6);
  Wire.setClock(100000);
  // ƒê·∫∑t l·∫°i c·∫£m bi·∫øn ch·∫ø ƒë·ªô operating (n·∫øu c·∫ßn)
  myIMU.setOperatingMode();
  delay(30);
  return false;
}

// ---------- Blynk callbacks ----------
// N·∫øu user t·∫Øt V0 tr√™n app (set 0) -> reset tr·∫°ng th√°i b√°o ƒë·ªông ƒë·ªÉ re-arm
BLYNK_WRITE(V0) {
  int v = param.asInt();
  if (v == 0 && freefallTriggered) {
    freefallTriggered = false;
    freefallStart = 0;
    Serial.println("User reset V0 -> re-armed");
    digitalWrite(STATUS_LED, LOW);
  }
}

// (t√πy ch·ªçn) V1 c√≥ th·ªÉ d√πng ƒë·ªÉ b·∫≠t/t·∫Øt ch·∫ø ƒë·ªô c·∫£nh b√°o; kh√¥ng b·∫Øt bu·ªôc
BLYNK_WRITE(V1) {
  int v = param.asInt();
  sensorActive = (v != 0);
  Serial.print("Sensor active set to ");
  Serial.println(sensorActive ? "ON" : "OFF");
  if (!sensorActive) {
    freefallStart = 0;
  }
}

// ---------- Setup ----------
void setup() {
  Serial.begin(115200);
  pinMode(STATUS_LED, OUTPUT);
  digitalWrite(STATUS_LED, LOW);

  // I2C
  Wire.begin(5, 6);           // SDA=5, SCL=6 (theo ph·∫ßn c·ª©ng b·∫°n d√πng)
  Wire.setClock(100000);     // 100 kHz cho ·ªïn ƒë·ªãnh

  Serial.println("Starting KX023 free-fall detector");

  if (myIMU.begin() != KX023_STATUS_OK) {
    Serial.println("‚ùå KX023 init FAILED. Check wiring (SDA,SCL,3.3V,GND).");
    sensorInitialized = false;
  } else {
    myIMU.configAsynchronousReadBackAccelerationData(KX023_ACCLERATION_RANGE_2G, KX023_ODR_50HZ);
    myIMU.setOperatingMode(); // b·∫≠t ƒëo
    sensorInitialized = true;
    Serial.println("‚úÖ KX023 initialized OK.");
  }

  // Blynk
  Blynk.begin(auth, ssid, pass);
  Blynk.virtualWrite(V0, 0); // ƒë·∫£m b·∫£o V0=0 ban ƒë·∫ßu
}

// ---------- Loop ----------
void loop() {
  Blynk.run();

  if (!sensorInitialized || !sensorActive) {
    delay(100);
    return;
  }

  unsigned long now = millis();
  if (now - lastSample < SAMPLE_INTERVAL_MS) return;
  lastSample = now;

  // ƒë·ªçc an to√†n
  if (!safeReadAccel(&ax, &ay, &az)) {
    // n·∫øu ƒë·ªçc l·ªói, b·ªè m·∫´u n√†y
    return;
  }

  // magnitude (g)
  float mag = sqrt(ax*ax + ay*ay + az*az);

  // debug
  Serial.print("mag=");
  Serial.print(mag, 3);
  Serial.print("  threshold=");
  Serial.println(FREEFALL_THRESHOLD, 3);

  // free-fall: magnitude r·∫•t nh·ªè (g·∫ßn 0)
  if (mag < FREEFALL_THRESHOLD) {
    if (freefallStart == 0) {
      freefallStart = now; // b·∫Øt ƒë·∫ßu ƒë·∫øm
      Serial.println("‚Üí possible free-fall start");
    } else {
      unsigned long elapsed = now - freefallStart;
      if (elapsed >= HOLD_TIME_MS && !freefallTriggered) {
        // k√≠ch ho·∫°t c·∫£nh b√°o: set V0 = 1 (user mu·ªën trigger V0)
        freefallTriggered = true;
        Serial.println("üö® FREE-FALL DETECTED -> trigger V0 = 1");
        Blynk.virtualWrite(V0, 1);
        digitalWrite(STATUS_LED, HIGH);
      } else {
        Serial.print("‚Üí free-fall counting ");
        Serial.print(elapsed);
        Serial.println(" ms");
      }
    }
  } else {
    // n·∫øu ng·∫Øt qu√£ng, reset b·ªô ƒë·∫øm (ch·ªâ khi v·∫´n ch∆∞a triggered)
    if (!freefallTriggered && freefallStart != 0) {
      Serial.println("‚Üí free-fall interrupted -> reset counter");
      freefallStart = 0;
    }
  }
}
